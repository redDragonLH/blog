# 内存机制与垃圾回收
JS内存空间分为**栈(stack)** 、**堆(heap)** 、**池（一般归类为栈中）** 。栈存放变量，堆存放复杂对象，池存放常量

## 基础数据类型与栈内存
js中的基础数据类型，都有固定的大小，往往保存在栈内存中，由系统自动分配存储空间。可以直接操作保存咋子栈内存空间的值，因此**基础数据类型都是按值访问**。 数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循**后进先出**的原则。 基础数据类型： `Number` `String` `Null` `Undefined` `Boolean`.

## 引用数据类型与堆内存
JS的引用数据类型的值是不固定的，引用数据类型的值是保存在**堆内存**中的**对象**,JS不允许直接访问堆内存中的位置，因此不能直接操作对象的堆内存空间。在操作**对象**时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的，这里的引用，可以理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联

要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据

例：

    var a = 20;
    var b = a; // 会分配一个新值，并不会使用同一个内存地址，所以不会互相影响
    b = 30;
    // 这时a的值是多少？

## 内存生命周期
1. 内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存


      var a = 20; // 在内存中给数值变量分配空间
      alert(a + 100); // 使用内存
      var a = null; // 使用完毕之后，释放内存空间
    

# 垃圾回收

* 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。

* 以Google的V8引擎为例，在V8引擎中所有的JAVASCRIPT对象都是通过堆来进行内存分配的。当我们在代码中声明变量并赋值时，V8引擎就会在堆内存中分配一部分给这个变量。如果已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止（默认情况下，V8引擎的堆内存的大小上限在64位系统中为1464MB，在32位系统中则为732MB）。

* 另外，V8引擎对堆内存中的JAVASCRIPT对象进行分代管理。新生代：新生代即存活周期较短的JAVASCRIPT对象，如临时变量、字符串等； 老生代：老生代则为经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

## 垃圾回收算法
### 引用计数法
老的ie使用的算法

引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。

但是有循环引用的bug问题
### 标记清除算法
大部分现代浏览器使用的算法

标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。
## 内存泄漏
对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）

### 内存泄漏的识别方法
#### 命令行方法
命令行可以使用 Node 提供的 `process.memoryUsage` 方法。

        console.log(process.memoryUsage());
        // { rss: 27709440,
        // heapTotal: 5685248,
        // heapUsed: 3449392,
        // external: 8772 }

process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，含义如下。

* `rss（resident set size）`：所有内存占用，包括指令区和堆栈。
* `heapTotal`："堆"占用的内存，包括用到的和没用到的。
* `heapUsed`：用到的堆的部分。
* `external`： V8 引擎内部的 C++ 对象占用的内存。

判断内存泄漏，以`heapUsed`字段为准。

### WeakMap
ES6新推出的两个数据结构 `WeakSet` 和 `WeakMap`

        const wm = new WeakMap();

        const element = document.getElementById('example');

        wm.set(element, 'some information');
        wm.get(element) // "some information"

